#  4 Ajustar las observaciones para tener 1000 puntos entre el intervalo
#  de dosificación de 0 a 8 horas, almacenar esta configuración en una lista.
#  5 Configurar un vector con parámetros a simular.
#  6 Pre-localizar un vector con 1000 posiciones.
#  7 Colocar en cada posición del vector un data.frame con simulaciones
#  originadas a partir del diseño presente en el set de datos original.
#  8 Realizar la simulación teniendo en cuenta el archivo de proyecto con
#  *simulx*. Elaborar una lista con 1000 tablas que contienen las simulaciones.
# Se demora 6 minutos aproxim.
#................................................................................
project.file <- '1_M_Error_1.mlxtran'
# Parámetros poblacionales
param <-
read_csv(file.path(auxdir, "populationParameters.txt"),
col_types = cols()) %>%
select(-se_sa, -rse_sa) %>%
column_to_rownames(var = "parameter")
N = 1e2
param <- setNames(pull(param), as.character(rownames(param)))
out1  <- list(name = 'y_1', time = seq(0, 8, length.out = N))
data_list <- vector(mode = "list", length = N)
# simulx(project = project.file)
covLev <- data_TAD$covariate %>%
mutate(across(c('id', 'SCRMGDL'), ~ as.numeric(as.character(.x))))
# ptm <- proc.time()
pb <- progress_bar$new(format = "[:bar] :current/:total (:percent) eta: (:eta)",
total = N)
for (i in 1:N) {
pb$tick()
suppressWarnings(
data_list[i] <- simulx(
project = project.file,
parameter = list(param, covLev),
treatment = data_TAD$treatment,
output = list(out1),
settings = list(load.design=TRUE)
)['y_1']
)
# print(paste('Lista la interacción N.º: ', i))
}
# print(proc.time() - ptm)
# Demora 6 minutos
##------------------------------------------------------------------------------#
## Nombre del Script: Script de generación de VPC -------------------------------
##
## Propósito del Script: crear gráficos de chequeo predictivo visual mediante
##  simulación por medio del paquete MLXR de Monolix.
##
## Autor: Daniel S. Parra González
## Fecha de creación: 18-02-2020
##
## Copyright (c) Daniel S. Parra, 2020
##
## Email: dsparrag@unal.edu.co
##------------------------------------------------------------------------------#
#-------------------------------------------------------------------------------#
# Introducción -----------------------------------------------------
#-------------------------------------------------------------------------------#
# Carga de paquetes
require(tidyverse)
require(progress)
require(rlang)
monolix2019R2.path <-  "C:/ProgramData/Lixoft/MonolixSuite2019R2"
require(lixoftConnectors, lib.loc = monolix2019R2.path )
require(mlxR)
initMlxR(path = monolix2019R2.path)
#-------------------------------------------------------------------------------#
auxdir <- file.path('BASE_MODEL')
#-------------------------------------------------------------------------------#
# Apertura y modificación de archivo de datos con observaciones
#-------------------------------------------------------------------------------#
#................................................................................
#  1 Abrir archivo de observaciones TAD
#  2 Filtrar sólo eventos de observación (EVID == 0)
#  3 Renombrar columnas para armonizar con archivo de simulación
#  4 Cambiar el tipo de columna para ID a factor
#  5 Reasignar la variable data_TAD como una nueva variable tipo lista
#  para el comando SimulX.
#................................................................................
# Lectura de archivo de observaciones
data_TAD <- read_delim(
"data/2_data_TAD.csv",
",", escape_double = FALSE, locale = locale(),
trim_ws = TRUE, na = ".")
data_OBS <- data_TAD %>%
filter(EVID == 0) %>%
rename(time = TIME, id = ID, y_1 = DV) %>%
mutate(id = factor(id))
data_TAD <-
"data/2_data_TAD.csv" %>%
mlxR::readDatamlx(datafile = .,
header = c("id", "y", "mdv", "evid",	"amt", "rate",
"addl", "ii", "ss", "time",
rep('ignore', 5), 'contcov', rep('ignore', 15)))
#-------------------------------------------------------------------------------#
# Simulación de parámetros teóricos ---------------------------------------
#-------------------------------------------------------------------------------#
# El objetivo es simular 1000 set de datos con el diseño de dosis y
# covariables original. Con esto se generan varios modelos teóricas que se
# deben comparar con las observaciones empíricas.
#................................................................................
#  1 Seleccionar el archivo con el Modelo de Monolix obtenido, este fue
#  modificado con un archivo de datos con TAD en lugar de TSFD.
#  2 Abrir el archivo de parámetros poblacionales
#  3 Asignar los nombres a un vector
#  4 Ajustar las observaciones para tener 1000 puntos entre el intervalo
#  de dosificación de 0 a 8 horas, almacenar esta configuración en una lista.
#  5 Configurar un vector con parámetros a simular.
#  6 Pre-localizar un vector con 1000 posiciones.
#  7 Colocar en cada posición del vector un data.frame con simulaciones
#  originadas a partir del diseño presente en el set de datos original.
#  8 Realizar la simulación teniendo en cuenta el archivo de proyecto con
#  *simulx*. Elaborar una lista con 1000 tablas que contienen las simulaciones.
# Se demora 6 minutos aproxim.
#................................................................................
project.file <- '1_M_Error_1.mlxtran'
# Parámetros poblacionales
param <-
read_csv(file.path(auxdir, "populationParameters.txt"),
col_types = cols()) %>%
select(-se_sa, -rse_sa) %>%
column_to_rownames(var = "parameter")
N = 1e2
param <- setNames(pull(param), as.character(rownames(param)))
out1  <- list(name = 'y_1', time = seq(0, 8, length.out = N))
data_list <- vector(mode = "list", length = N)
# simulx(project = project.file)
covLev <- data_TAD$covariate %>%
mutate(across(c('id', 'SCRMGDL'), ~ as.numeric(as.character(.x))))
# ptm <- proc.time()
pb <- progress_bar$new(format = "[:bar] :current/:total (:percent) eta: (:eta)",
total = N)
for (i in 1:N) {
pb$tick()
suppressMessages(
data_list[i] <- simulx(
project = project.file,
parameter = list(param, covLev),
treatment = data_TAD$treatment,
output = list(out1),
settings = list(load.design=TRUE)
)['y_1']
)
# print(paste('Lista la interacción N.º: ', i))
}
# print(proc.time() - ptm)
# Demora 6 minutos
#-------------------------------------------------------------------------------#
options(dplyr.summarise.inform = FALSE) # Elimina unos mensajes molestos
dfr_percs <- data_list %>%
map(~ mutate(.x, gr = ntile(time, 100))) %>%
map(~ group_by(.x, gr)) %>%
map( ~ summarise(.x, TIME = mean(time),
ME = quantile(x = y_1, probs = 0.50),
LI = quantile(x = y_1, probs = 0.10),
LS = quantile(x = y_1, probs = 0.90))) %>%
map_dfr(~ as.data.frame(.x), .id = 'sim_id')
dfr_percs
dfr_percs1 <- dfr_percs %>%
group_by(gr) %>%
summarise(TIME = mean(TIME),
ME_me = quantile(ME, probs = 0.50),
ME_li = quantile(ME, probs = 0.05),
ME_ls = quantile(ME, probs = 0.95),
LI_me = quantile(LI, probs = 0.50),
LI_li = quantile(LI, probs = 0.05),
LI_ls = quantile(LI, probs = 0.95),
LS_me = quantile(LS, probs = 0.50),
LS_li = quantile(LS, probs = 0.05),
LS_ls = quantile(LS, probs = 0.95) )
data_OBS1 <- data_OBS %>%
mutate(gr = ntile(time, 6)) %>%
group_by(gr) %>%
summarise(TIME = mean(time),
ME = quantile(x = y_1, probs = 0.50),
LI = quantile(x = y_1, probs = 0.10),
LS = quantile(x = y_1, probs = 0.90),
n = n())
#-------------------------------------------------------------------------------#
# Creación del gráfico VPC con percentiles --------------------------------
#-------------------------------------------------------------------------------#
# Función que adiciona lineas y puntos, diseñada para observaciones
linedots <- function(data, x, y) {
x = rlang::ensym(x)
y = rlang::ensym(y)
return(
list(geom_line(data = data, aes(x = !!x, y = !!y), col='red'),
geom_point(data = data, aes(x = !!x, y = !!y),col='red',shape=15))
)
}
# VPC con percentiles predichos
theme_set(theme_bw() +
theme(panel.border = element_rect(fill = NULL, colour = 'black')))
g_percs <- dfr_percs1 %>%
ggplot(aes(x = TIME)) +
geom_ribbon(aes(ymin = ME_li, ymax = ME_ls), alpha = 0.5, fill = 'gray70') +
geom_ribbon(aes(ymin = LI_li, ymax = LI_ls), alpha = 0.5, fill = 'gray30') +
geom_ribbon(aes(ymin = LS_li, ymax = LS_ls), alpha = 0.5, fill = 'gray30') +
geom_line(aes(y=ME_me), lty='dashed') +
geom_line(aes(y=LI_me), lty='dashed') +
geom_line(aes(y=LS_me), lty='dashed') +
linedots(data_OBS1, TIME, ME) +
linedots(data_OBS1, TIME, LI) +
linedots(data_OBS1, TIME, LS) +
theme_bw() +
coord_cartesian(ylim = c(0, 100)) +
theme(panel.border = element_rect(fill = NULL, colour = 'black')) +
xlab('TAD, tiempo tras dosis (h)') +
ylab('Concentración plasmática FEP (mg/L)')
# Almacenamiento en formato PDF
ggsave('figures/VPC_percentil.pdf', g_percs, 'pdf',
width = 6, height = 5)
g_percs
param["omega_Cl"] <- 0
param["omega_V1"] <- 0
param["omega_Q"] <- 0
param["omega_V2"] <- 0
param["a"] <- 0
param["b"] <- 0
data_pred <- simulx(project = project.file,
parameter = param,
treatment = data_TAD$treatment,
output = out1)[['y_1']]
data_pred_1 <- data_pred %>%
mutate(gr = ntile(time, 100)) %>%
group_by(gr) %>%
summarise(time_bin = mean(time),
ME_bin = quantile(x = y_1, probs = 0.50))
data_pred = data_pred %>%
mutate(gr = ntile(time, 100)) %>%
left_join(., data_pred_1, by = 'gr') %>%
mutate(time = round(time, 4)) %>%
as_tibble(.)
data_list <-  data_list %>%
map( ~ mutate(.x, time = round(time, 4))) %>%
map(~ mutate(.x, gr = ntile(time, 100))) %>%
map(~ left_join(.x, data_pred,
by = c('id', 'gr', 'time')))
dfr_percs_pcVPC <- data_list %>%
map_dfr( ~ as.data.frame(.x), .id = 'sim_id') %>%
mutate(pcy_1 = y_1.x * ME_bin / y_1.y) %>%
group_by(sim_id, gr) %>%
summarise(TIME = mean(time),
ME = quantile(x = pcy_1, probs = 0.50),
LI = quantile(x = pcy_1, probs = 0.10),
LS = quantile(x = pcy_1, probs = 0.90))
dfr_percs1_pcVPC <- dfr_percs_pcVPC %>%
ungroup(.) %>%
group_by(gr) %>%
summarise(TIME = mean(TIME),
ME_me = quantile(ME, probs = 0.50),
ME_li = quantile(ME, probs = 0.05),
ME_ls = quantile(ME, probs = 0.95),
LI_me = quantile(LI, probs = 0.50),
LI_li = quantile(LI, probs = 0.05),
LI_ls = quantile(LI, probs = 0.95),
LS_me = quantile(LS, probs = 0.50),
LS_li = quantile(LS, probs = 0.05),
LS_ls = quantile(LS, probs = 0.95) )
out2 <- list(name = 'y_1', time = data_TAD$y$time)
data_OBS_PRED <- simulx(project = project.file,
parameter = param,
treatment = data_TAD$treatment,
output = out2)[['y_1']] %>%
rename(PRED = y_1)
data_OBS_PRED_tile <- data_OBS_PRED %>%
mutate(gr = ntile(time, 6)) %>%
group_by(gr) %>%
summarise(time_bin = mean(time),
ME_PRED = quantile(x = PRED, probs = 0.50))
data_OBS_PRED <- data_OBS_PRED %>%
mutate(gr = ntile(time, 6)) %>%
left_join(., data_OBS_PRED_tile, by = 'gr') %>%
mutate(time = round(time, 4))
data_OBS_PRED_sum <- data_OBS %>%
mutate(time = round(time, 4)) %>%
left_join(., data_OBS_PRED, by = c('id', 'time')) %>%
mutate(pcVPC = y_1 * ME_PRED / PRED) %>%
group_by(gr) %>%
summarise(
TIME = mean(time),
ME = quantile(x = y_1, probs = 0.50),
LI = quantile(x = y_1, probs = 0.10),
LS = quantile(x = y_1, probs = 0.90),
n = n()
)
#-------------------------------------------------------------------------------#
# VPC con percentiles predichos corregidos por PRED
g_percs1 <-
dfr_percs1_pcVPC %>%
ggplot(aes(x = TIME)) +
geom_ribbon(aes(ymin = ME_li, ymax = ME_ls), alpha = 0.5, fill = 'gray70') +
geom_ribbon(aes(ymin = LI_li, ymax = LI_ls), alpha = 0.5, fill = 'gray30') +
geom_ribbon(aes(ymin = LS_li, ymax = LS_ls), alpha = 0.5, fill = 'gray30') +
geom_line(aes(y=ME_me), lty='dashed') +
geom_line(aes(y=LI_me), lty='dashed') +
geom_line(aes(y=LS_me), lty='dashed') +
linedots(data_OBS_PRED_sum, TIME, ME) +
linedots(data_OBS_PRED_sum, TIME, LI) +
linedots(data_OBS_PRED_sum, TIME, LS) +
theme_bw() +
theme(panel.border = element_rect(fill = NULL, colour = 'black')) +
coord_cartesian(ylim = c(0, 100)) +
xlab('TAD, tiempo tras dosis (h)') +
ylab('Concentración plasmática FEP \n Corregida por concentración (mg/L)')
g_percs1
# Almacenamiento del archivo PDF
ggsave(filename = 'figures/pcVPC_percentil.pdf', g_percs1,
device = 'pdf', width = 6, height = 5)
#-------------------------------------------------------------------------------#
# Almacenar RDS
saveRDS(g_percs, 'figures/RDS/VPC_percentil.rds')
saveRDS(g_percs1, 'figures/RDS/pcVPC_percentil.rds')
source("~/(Proyecto)_Estudio_PKPD/CEFEPIME/15. Final/8_Modelo_Final/src/4_VPC.R", encoding = 'UTF-8', echo=TRUE)
NPC_plot
source("~/(Proyecto)_Estudio_PKPD/CEFEPIME/15. Final/8_Modelo_Final/src/5_NPC.R", encoding = 'UTF-8', echo=TRUE)
source("~/(Proyecto)_Estudio_PKPD/CEFEPIME/15. Final/8_Modelo_Final/src/5_NPC.R", encoding = 'UTF-8', echo=TRUE)
3+3
NPC_plot
NPC_conplot
##------------------------------------------------------------------------------#
## Nombre del Script: Cálculo de NPC modelo de covariables final
##
## Propósito del Script:  Realizar una chequeo predictivo numérico en el modelo
## de covariables final
##
## Autor: Daniel S. Parra González
## Fecha de creación: 30-05-2020
##
## Copyright (c) Daniel S. Parra, 2020
##
## Email: dsparrag@unal.edu.co
##------------------------------------------------------------------------------#
monolix2019R2.path <-  "C:/ProgramData/Lixoft/MonolixSuite2019R2"
require(lixoftConnectors, lib.loc = monolix2019R2.path )
require(mlxR)
initMlxR(path = monolix2019R2.path)
require(tidyverse)
require(patchwork)
#-------------------------------------------------------------------------------#
# Introducción  -----------------------------------------------------------------
#-------------------------------------------------------------------------------#
#
project.file <- '1_M_Error_1.mlxtran'
# Remuestreo de pacientes iniciales
# Números de simulaciones del diseño experimental
N <- 500*15 # 7500
# Realizar simulaciones desde el archivo
res1 <- simulx(project = project.file,
group = list(size = N))
# Crear un data.frame con simulaciones
res2 <- res1$y_1 %>%
as_tibble() %>%
left_join(res1$originalId, by = c('id' = 'newId')) %>%
add_column(sim_id = rep(1:(N/15), each=15*6)) %>%
group_by(oriId) %>%
mutate(TAD = time - min(time))
res2
# ggplot(res2, aes(x=TAD, y=y_1, col=oriId)) +
#   geom_point() +
#   facet_wrap(.~id)
# Leer archivo TAD con observaciones
data_TAD <- read_csv("data/2_data_TAD.csv", na = '.')
data_TAD_1 <- data_TAD %>% filter(EVID == 0)
#-------------------------------------------------------------------------------#
# Chequeo Predictivo Numérico (NPC)   -------------------------------------------
#-------------------------------------------------------------------------------#
#' Función de procedimiento NPC
#'
#' @param obs vector con concentraciones observados (Cobs)
#' @param sim vector con concentraciones simuladas (Csim)
#' @param PI  vector de intervalos de predicción (IP)
#'
#' @return
#' Los vectores Cobs y Csim tienen que estar alineados de manera que se repite
#' la simulación varios veces.
#' @export
#' data.frame con ratio de OE, intervalo inferior, y superior, y tipo de límite
#' de intervalo de predicción (IP).
#'
#' @examples npc(obs = data_TAD_1$DV, sim = res2$y_1, PI = seq(5, 90, by = 5))
#'
npc <- function (obs, sim,PI){
nobs <- length(obs)
nrep <- length(sim)[1]/nobs
# Cálculo de límites inferior y superior de cada intervalo de predicción (IP)
# en forma de percentiles
percentiles <- c(50-PI/2, (50+PI/2))
# Conversión de vector Csim en matriz con una columna por cada repetición
matsimfull <- matrix(sim, ncol = nrep)
# Cálculo de los percentiles en cada simulación
matsimper <- t(apply(matsimfull,1,quantile,percentiles/100))
matsimper_lower <- matsimper[,1:length(PI)]
matsimper_upper <- matsimper[,(length(PI)+1):length(percentiles)]
# Verificación de cobertura de datos simulados
sim_outlower <- c()
sim_outupper <- c()
for (i in 1:length(PI)) {
# Verificación si datos simulados son menores a percentiles
matsim_outlower <- ifelse(matsimfull < matsimper_lower[, i], 1, 0)
sim_outlower <-
cbind(sim_outlower, quantile(apply(matsim_outlower, 2, mean), c(0.025, 0.5, 0.975)))
# Verificación si datos simulados son mayores a percentiles
matsim_outupper <-
ifelse(matsimfull > matsimper_upper[, i], 1, 0)
sim_outupper <-
cbind(sim_outupper, quantile(apply(matsim_outupper, 2, mean), c(0.025, 0.5, 0.975)))
}
# Repetición de vector de observaciones con columnas para cada intervalo de predicción
yobs_lower      <- matrix(rep(obs, length(PI)), ncol = length(PI))
yobs_upper      <- matrix(rep(obs, length(PI)), ncol = length(PI))
# Verificación si observación es menor a limite inferior para cada IP
yobs_lower      <- ifelse(yobs_lower < matsimper_lower, 1, 0)
# Verificación si observación es menor a limite superior para cada IP
yobs_upper      <- ifelse(yobs_upper > matsimper_upper, 1, 0)
# Cálculo de proporción de OUTLIERS como valor medio
obsper_outlower <- apply(yobs_lower, 2, mean)
obsper_outupper <- apply(yobs_upper, 2, mean)
# Cálculo de cobertura como razón OE - proporción de valores observados (Cobs)
# sobre valores esperados (Csim)
lower_cover     <- obsper_outlower / sim_outlower[2,]
CI_lower_cover  <- t(t(sim_outlower[c(1, 3),]) / sim_outlower[2,])
upper_cover     <- obsper_outupper / sim_outupper[2,]
CI_upper_cover  <- t(t(sim_outupper[c(1, 3),]) / sim_outupper[2,])
# Número de datos OUTLIERS
lower_out <-
(lower_cover < CI_lower_cover[1, ]) + (lower_cover > CI_lower_cover[2, ])
upper_out <-
(upper_cover < CI_upper_cover[1, ]) + (upper_cover > CI_upper_cover[2, ])
# Creación de datos de cobertura
cover <- as.data.frame(cbind(
rep(PI, 2),
c(lower_cover, upper_cover),
c(lower_out, upper_out),
rbind(t(CI_lower_cover), t(CI_upper_cover))
), row.names = F)
cover$Type <-
rep(c("Limite IP inferior", "Limite IP superior"), each = length(PI))
colnames(cover) <- c("PI","Ratio","Outliers","Lwr","Sup","Tipo")
return(cover)}
#-------------------------------------------------------------------------------#
# Tabla con resultados de NPC
df <- npc(obs = data_TAD_1$DV, sim = res2$y_1,
PI = seq(5, 90, by = 5))
# Gráfico de NPC
NPC_plot <- df %>%
ggplot(aes(x = PI, y = Ratio,
group = Tipo, col = Tipo, fill = Tipo)) +
geom_ribbon(aes(ymin = Lwr, ymax = Sup), alpha = 0.8) +
geom_line(col = 'black') +
geom_point(col = 'black') +
facet_grid(Tipo ~ .) +
geom_hline(yintercept = 1, lty = 'dotted') +
ylab('Ratio O/E') + xlab('Intervalos de predicción (IP)') +
theme_bw() +
theme(panel.border = element_rect(fill = NULL, colour = 'black'),
legend.position = "none") +
scale_fill_manual(values = c('#85B8FF', '#FF886B')) +
scale_color_manual(values = c('#85B8FF', '#FF886B'))
NPC_plot
# Apertura de gráfico de VPC almacenado
VPC_plot <- readRDS('figures/RDS/pcVPC_percentil.rds')
# Formación de gráfico compuesto
NPC_conplot <- (VPC_plot + theme_bw()) +
NPC_plot + plot_annotation(tag_levels = 'A')
# Almacenamiento del archivo PDF
ggsave(filename = 'figures/NPC_plot.pdf', NPC_plot, device = 'pdf',
width = 4/1.2, height = 6/1.2)
ggsave(filename = 'figures/VPC_NPC_plot.pdf', NPC_conplot, device = 'pdf',
width = 8, height = 5)
NPC_plot
VPC_plot
# Apertura de gráfico de VPC almacenado
VPC_plot <- readRDS('figures/RDS/pcVPC_percentil.rds') + theme_bw()
# Formación de gráfico compuesto
NPC_conplot <- wrap_plots(VPC_plot, NPC_plot) +
plot_annotation(tag_levels = 'A') +
plot_layout(design = c(0.7, 0.3))
NPC_conplot
wrap_plots(VPC_plot, NPC_plot)
wrap_plots(VPC_plot, NPC_plot) +
plot_annotation(tag_levels = 'A') +
plot_layout(design = c(0.7, 0.3))
# Formación de gráfico compuesto
NPC_conplot <- wrap_plots(VPC_plot, NPC_plot) +
plot_layout(design = c(0.7, 0.3)) +
plot_annotation(tag_levels = 'A')
NPC_conplot
# Formación de gráfico compuesto
NPC_conplot <- wrap_plots(VPC_plot, NPC_plot) +
plot_layout(widths = c(0.7, 0.3)) +
plot_annotation(tag_levels = 'A')
NPC_conplot
# Almacenamiento del archivo PDF
ggsave(filename = 'figures/NPC_plot.pdf', NPC_plot, device = 'pdf',
width = 4/1.2, height = 6/1.2)
ggsave(filename = 'figures/VPC_NPC_plot.pdf', NPC_conplot, device = 'pdf',
width = 8, height = 5)
# Formación de gráfico compuesto
NPC_conplot <- wrap_plots(VPC_plot, NPC_plot) +
plot_layout(widths = c(0.65, 0.25)) +
plot_annotation(tag_levels = 'A')
# Formación de gráfico compuesto
NPC_conplot <- wrap_plots(VPC_plot, NPC_plot) +
plot_layout(widths = c(0.65, 0.35)) +
plot_annotation(tag_levels = 'A')
NPC_conplot
# Almacenamiento del archivo PDF
ggsave(filename = 'figures/NPC_plot.pdf', NPC_plot, device = 'pdf',
width = 4/1.2, height = 6/1.2)
ggsave(filename = 'figures/VPC_NPC_plot.pdf', NPC_conplot, device = 'pdf',
width = 8, height = 4.5)
